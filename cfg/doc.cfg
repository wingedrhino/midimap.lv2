# midimap.lv2 - config/map file
#
# Lines starting with a hash (#) are ignored, as are empty lines.
# Note that: whitespace is significant (beware of trailing spaces).
#

# at first we need to set the file-format version,
midimap v1

# forward all events that don't match a filter-rule as-is
# is not set, only events matching a rule will generate output
forward-unmatched

#### Filter Rules
##
## Here comes the tricky part :) -- see below for aliases and simple example
##
## The general form is
##
##    <FILTER-MATCH> | <REPLACEMENT>
##

### Filter description
##
## The MIDI filter consists of up to three whitespace separated fields
## which are matched against the bytes of a MIDI message
##
## For note-events (3 bytes) the fields are
##   Type|Channel Key Velocity
##
## For control-changes
##   Type|Channel Control Value
##
## see also http://www.midi.org/techspecs/midimessages.php
##
## Each of the filter fields is a number pairs separated by a slash:
##    <match>/<byte-mask>
## The numbers can be given in decimal or hexadecimal.
## a prefix "0x" indicates the latter.
##
## the byte-mask may be omited in which case it is 0xff (match value exactly)
##

### Replacement description
##
## like the filter, replacement also consiste of two fields per midi-byte
##    <set>/<byte-mask>
## the existing midi message is binary-AND masked and the result is
## binary-OR combined with the <set> number.
##
## the byte-mask may be omited in which case it is 0x00 (set value)
##
## currently the replacement must have the same length as the incoming
## message.
##

### Replacement strategy
##
## for every incoming message all rules are evaluated.
## if more than one rule matches, messsage for all rules are generated.
##

#### Examples
##
# 0x80/0xe0 0/0 0/0 | 0x05/0xf0 0/0x7f 0/0x7f
#
## 0x80/0xe0   matches all note events
##   (note-off = 0x80 .. 0x8f for chan 0..15)
##   (note-on  = 0x90 .. 0x9f for chan 0..15)
## the evaluated filter expression (status_byte & 0xe0) == 0x80
##
## next are two "any" placeholders for key and velocity
## any value AND 0 will be zero.
##
## So this Filter matches all note-on and all note-off events.
##
## The second part after the pipe (|) is the message that is generated
## every time this filter is matched
##
## 0x05/0xf0
##   take the existing status AND with 0xf0, this strips the channel (1..f) but
##   leaves the status (note-on (0x90), note-off 0x80) in place.
##   next it is OR'ed with 0x05 (midi channel 5)
##
## 0/0x7f  for key and velocity just pass the value as-is
##   AND 0x7f leaves all 7bits (0..127) as-is,  OR 0 adds nothing
##
## The above rule just forces all note-on/off events to channel 5.
##
## another example:
#
# 0x90/0xf0 0/0 0 | 0x80/0x0f 0/0x7f 0
#
## This translates all note-on events with velocity zero, to note-off events,
## while keeping the midi-channel.
## The filter is
##   0x90/0xf0  -- matches all note-on (0x90 .. 0x9f)
##   0/0        -- regardless of key
##   0          -- with velocity 0 (could also be written as 0x0/0x7f)
## the replacement is
##   0x80/0x0f  -- keep channel only (0x0f) then set note-off (0x80)
##   0/0x7f     -- keep key as-is (0x7f)
##   0          -- set velocity to 0
##

#### Placeholders / Shortcuts
##
## shortcuts are case-insensitive, following StatusByte filters are available:
##  'ANY'          == "0x00/0x00"  // Any message
##  "Note"         == "0x80/0xe0"  // Note on and off, 3 bytes
##  "NoteOff"      == "0x80/0xf0"  // Note off, 3 bytes
##  "NoteOn"       == "0x90/0xf0"  // Note on, 3 bytes
##  "KeyPressure"  == "0xa0/0xf0"  // Polyphonic Key Pressure, 3bytes
##  "CC"           == "0xb0/0xf0"  // Control Change, 3 bytes
##  "Pitch"        == "0xe0/0xf0"  // Pitch Bend, 3 bytes
##  "NOTEC<NUM>"   == "0x8X/0xeX"  // Note on and off for the given channel
##
## for the data bytes
##  'ANY'          == "0x00/0x00"  // Any value
## 
## likewise in the replacement section:
##  'SAME'         == "0x00/0xff"  // keep value as-is
##  "CHN<NUM>"     == "0x0X/0xfX"  // keep status, set channel (only for status byte)
##
##
## The the following rule
#
# NOTE ANY ANY | 0x05/0xf0 SAME SAME
#
## is eqivalent to the one we've seen above:
#
# 0x80/0xe0 0/0 0/0 | 0x05/0xf0 0/0x7f 0/0x7f
#
##
## Here's a rule that translates the note "C3" on channel 5 to "A3 on channel 7
#
# NOTEC5 60 ANY | CHN7 58 SAME
#
## it it is evivalent to 
#
# 0x85/0xef 60/0x7f 0/0 | 0x07/0xf0 58/0 0/0x7f
#


### Midi Note Shortcuts
##
## since midi-note numbers are not always convenient, there are shortcuts in the form of 
##
##    <key>[#b]<octave>
##
## <key> is case-insensitive  a-g
## an optional modifier "#" sharp, or "b" flat
## followed by an octave -2 to 8
##
## Examples:
##   C-1   = note number 0
##   G#0   = note number 20
##   Bb8   = note number 118
##
## the following two are eqivalent
#
# NOTEC5 48 ANY | CHN7 69 SAME
# NOTEC5 C3 ANY | CHN7 A4 SAME
#
### That's it :)


#### More examples

## tranlate all C3 to C4, keep channel
# NOTE C3 ANY | SAME C4 SAME

## any note becomes an "A" on the first channel
# NOTE ANY ANY | CHN0 A3 SAME

## force all note events to channel 0
# NOTE ANY ANY | 0x00/0xf0 SAME SAME
## also force all note events to channel 0
# NOTE ANY ANY | CHN0 SAME SAME

## map note C3 on channel 5 to D2 on channel 1
# NOTEC5 C3 ANY | CHN1 D2 SAME

#### and finally a real active rule:

NOTE ANY ANY | CHN0 SAME SAME
